<!-- ENTANGLEMENT MINI GAME INDEX-->
<!DOCTYPE html> 
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Entanglement Minigame Prototype</title>
  <link rel="stylesheet" href="assets/css/style.css">
</head>
<body>
<div class="dreamy-overlay"></div>
<div class="background-gradient"></div>

<canvas id="gameCanvas"></canvas>

<div style="position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: white; font-family: Arial, sans-serif; font-size: 14px; text-align: center; z-index: 150; text-shadow: 2px 2px 4px black; pointer-events: none;">
</div>

<!-- MOBILE  -->
<div id="controls"> <!-- KEY M TO HIDE MOBILE CONTROLS-->
  <div class="joystick">
    <div class="joystick-knob"></div>
  </div>
  <div class="jump-btn"><img src="assets/images/jump.png"></div>
</div>

<script src="https://unpkg.com/kaplay@latest/dist/kaplay.js"></script>

<script>
// ======================================== VIRTUAL RESOLUTION ========================================
const VIRTUAL_W = 1000;
const VIRTUAL_H = 480;

let ACTUAL_W = window.innerWidth;
let ACTUAL_H = window.innerHeight;

function updateScreenDimensions(width, height) {
  ACTUAL_W = width;
  ACTUAL_H = height;
}

function getCanvasSize() {
  return {
    width: window.innerWidth,
    height: window.innerHeight,
  };
}

const FPS = 60;
const canvasSize = getCanvasSize();
updateScreenDimensions(canvasSize.width, canvasSize.height);
const GAME_SCALE = 2;
const SCREEN_W = VIRTUAL_W;
const SCREEN_H = VIRTUAL_H;

const k = kaplay({
  width: (SCREEN_W / 2) * GAME_SCALE,
  height: (SCREEN_H / 2) * GAME_SCALE,
  GAME_SCALE,
  letterbox: true,
  background: [11, 11, 27, 0],
  global: false,
  canvas: document.getElementById("gameCanvas"),
  debug: true,
  stretch: true,
  crisp: true,
});

window.k = k;
Object.assign(window, k);

// ======================================== MOBILE CONTROLS ========================================
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                  ('ontouchstart' in window);
const controls = document.getElementById('controls');
const joystick = document.querySelector('.joystick');
const joystickKnob = document.querySelector('.joystick-knob');
const jumpBtn = document.querySelector('.jump-btn');

const virtualKeys = {
  left: false,
  right: false,
  space: false
};

if (controls) {
  const updateOrientation = () => {
    const isPortrait = window.innerHeight > window.innerWidth;
    controls.className = isPortrait ? 'portrait' : 'landscape';
    
    if (isMobile) {
      controls.style.display = 'flex';
    }
  };
  
  updateOrientation();
  window.addEventListener('resize', updateOrientation);
  window.addEventListener('orientationchange', updateOrientation);
  
  let hasShown = false;
  window.addEventListener('touchstart', () => {
    if (!hasShown) {
      hasShown = true;
      controls.style.display = 'flex';
      updateOrientation();
    }
  }, { once: true });
}

let joystickActive = false;
let joystickCenter = { x: 0, y: 0 };
const joystickRadius = 60;
const deadZone = 15;

function updateJoystick(touch) {
  if (!joystickActive) return;
  
  const rect = joystick.getBoundingClientRect();
  joystickCenter.x = rect.left + rect.width / 2;
  joystickCenter.y = rect.top + rect.height / 2;
  
  const deltaX = touch.clientX - joystickCenter.x;
  const deltaY = touch.clientY - joystickCenter.y;
  const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  
  const clampedDistance = Math.min(distance, joystickRadius);
  const angle = Math.atan2(deltaY, deltaX);
  
  const knobX = Math.cos(angle) * clampedDistance;
  const knobY = Math.sin(angle) * clampedDistance;
  
  joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
  
  if (Math.abs(deltaX) > deadZone) {
    virtualKeys.left = deltaX < 0;
    virtualKeys.right = deltaX > 0;
  } else {
    virtualKeys.left = false;
    virtualKeys.right = false;
  }
}

function resetJoystick() {
  joystickActive = false;
  joystick.classList.remove('active');
  joystickKnob.style.transform = 'translate(-50%, -50%)';
  virtualKeys.left = false;
  virtualKeys.right = false;
}

if (joystick) {
  joystick.addEventListener('touchstart', (e) => {
    e.preventDefault();
    joystickActive = true;
    joystick.classList.add('active');
    updateJoystick(e.touches[0]);
  });
  
  joystick.addEventListener('touchmove', (e) => {
    e.preventDefault();
    updateJoystick(e.touches[0]);
  });
  
  joystick.addEventListener('touchend', (e) => {
    e.preventDefault();
    resetJoystick();
  });
  
  joystick.addEventListener('touchcancel', (e) => {
    e.preventDefault();
    resetJoystick();
  });
}

if (jumpBtn) {
  jumpBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    virtualKeys.space = true;
  });
  
  jumpBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    virtualKeys.space = false;
  });
  
  jumpBtn.addEventListener('touchcancel', (e) => {
    e.preventDefault();
    virtualKeys.space = false;
  });
}

const originalIsKeyDown = isKeyDown;
const originalIsKeyPressed = isKeyPressed;
const originalOnKeyPress = onKeyPress;
const originalOnKeyRelease = onKeyRelease;

let lastSpaceState = false;

window.isKeyDown = function(key) {
  if (virtualKeys[key]) return true;
  return originalIsKeyDown(key);
};

let spaceHandlers = [];
window.onKeyPress = function(key, callback) {
  if (key === "space") {
    spaceHandlers.push(callback);
  }
  return originalOnKeyPress(key, callback);
};

let checkMobileInput = () => {
  if (virtualKeys.space && !lastSpaceState) {
    spaceHandlers.forEach(handler => handler());
  }
  lastSpaceState = virtualKeys.space;
};

setInterval(checkMobileInput, 16);

window.addEventListener('keydown', (e) => {
  if (e.key === 'm' || e.key === 'M') {
    if (controls.style.display === 'flex') {
      controls.style.display = 'none';
    } else {
      controls.style.display = 'flex';
      const isPortrait = window.innerHeight > window.innerWidth;
      controls.className = isPortrait ? 'portrait' : 'landscape';
    }
  }
});

// ======================================== PHYSICS ========================================
setGravity(1500);
const MOVE_SPEED = 500;
const JUMP_FORCE = 780;
const LEVEL_HEIGHT = 4000;

// ======================================== LOAD SPRITES ========================================
loadSprite("groundPlatform", "assets/images/ground3.png");
loadSprite("platform", "assets/images/platform.png");
loadSprite("leftWall", "assets/images/leftWall2.png");
loadSprite("rightWall", "assets/images/rightWall2.png");

loadSprite("niels", "assets/images/Niels.png", {
  sliceX: 12,
  sliceY: 1,
  anims: {
    walk: {
      from: 0,
      to: 7,
      speed: 12,
      loop: true,
    },
  },
});


// ======================================== SPRITE PLATFORM CREATION ========================================
function createSpritePlatform(x, y, width, height, moveRange, moveSpeed, isActive = true) {
  const spriteWidth = 250;
  const scaleX = width / spriteWidth;
  const scaleY = 0.5;

  const spriteLayer = add([
    sprite("platform"),
    pos(x, y),
    anchor("center"), 
    scale(vec2(scaleX, scaleY)),
    opacity(1.0),
    z(6),
  ]);

  const collisionLayer = add([
    rect(width, height),
    pos(x - width/2, y - height/2),
    opacity(0),
    "oneWayPlatform",
    z(7)
  ]);

  collisionLayer.width = width;
  collisionLayer.height = height;
  collisionLayer.spriteLayer = spriteLayer;
  
  collisionLayer.centerX = x;
  collisionLayer.centerY = y;
  collisionLayer.isActive = isActive;
  collisionLayer.deltaX = 0;  

  // ========================================== MOVEMENT SETTINGS  ==========================================
  if (isActive) {
    const startCenterX = x;
    const minCenterX = startCenterX - moveRange;
    const maxCenterX = startCenterX + moveRange;

    let direction = 1;
    let lastCenterX = x;

    collisionLayer.onUpdate(() => {
      collisionLayer.centerX += moveSpeed * direction * dt();

      if (collisionLayer.centerX > maxCenterX) {
        collisionLayer.centerX = maxCenterX;
        direction = -1;
      }
      if (collisionLayer.centerX < minCenterX) {
        collisionLayer.centerX = minCenterX;
        direction = 1;
      }

      const deltaX = collisionLayer.centerX - lastCenterX;
      lastCenterX = collisionLayer.centerX;

      collisionLayer.pos.x = collisionLayer.centerX - width/2;
      collisionLayer.pos.y = y - height/2; 
      spriteLayer.pos.x = collisionLayer.centerX;
      spriteLayer.pos.y = y;

      collisionLayer.deltaX = deltaX;

      if (collisionLayer.sync) {
        const syncCenterX = collisionLayer.centerX + (VIRTUAL_W / 2);
        collisionLayer.sync.centerX = syncCenterX;
        collisionLayer.sync.pos.x = syncCenterX - width/2;
        collisionLayer.sync.pos.y = y - height/2;
        collisionLayer.sync.spriteLayer.pos.x = syncCenterX;
        collisionLayer.sync.spriteLayer.pos.y = y;
        collisionLayer.sync.deltaX = deltaX;  
      }
    });
  } else {
    collisionLayer.onUpdate(() => {
      if (!collisionLayer.deltaX) {
        collisionLayer.deltaX = 0;
      }
    });
  }

  return collisionLayer;
}


// ======================================== GROUND CREATION ========================================
function createSpriteGround(x, y, width, height) {
  const segmentWidth = 500;
  const numSegments = Math.floor(width / segmentWidth);
  for (let i = 0; i < numSegments; i++) {
    add([
      sprite("groundPlatform"),
      pos(x + (i * segmentWidth), y),
      scale(vec2(2, 2)),
      z(3),
    ]);
  }

  add([
    rect(width, height),
    pos(x, y),
    area(),
    body({ isStatic: true }),
    opacity(0),
    "ground",
    z(4) 
  ]);
}

// ======================================== ONE WAY PLATFORM SETUP ========================================
function setupOneWayPlatforms(player) {

  const hitboxHeight = player.area.height || 90;
  const hitboxOffsetY = player.area.offset?.y || 10;
  const hitboxWidth = player.area.width || 90;

  player.onUpdate(() => {
    let currentlyRiding = null;
    const platforms = get("oneWayPlatform");
    for (const platform of platforms) {
      const playerBottom = player.pos.y + (hitboxHeight / 2) + hitboxOffsetY;
      const platformTop = platform.pos.y;
      
      const playerLeft = player.pos.x - (hitboxWidth / 2);
      const playerRight = player.pos.x + (hitboxWidth / 2);
      const platformLeft = platform.pos.x;
      const platformRight = platform.pos.x + platform.width;
      
      const horizontalOverlap = playerRight > platformLeft && playerLeft < platformRight;
      const verticalDistance = playerBottom - platformTop;
      
      if (
        horizontalOverlap &&
        player.vel.y >= 0 &&
        verticalDistance >= -5 &&
        verticalDistance <= 15
      ) {
        player.pos.y = platformTop - (hitboxHeight / 2) - hitboxOffsetY;
        player.vel.y = 0;
        currentlyRiding = platform;
        break; 
      }
    }
    
    if (currentlyRiding && currentlyRiding.deltaX) {
      player.pos.x += currentlyRiding.deltaX;
    }
    
    player.ridingPlatform = currentlyRiding;
  });
}


// ======================================== SCENE ========================================
scene("vertical-test", () => {
  const LEVEL_HEIGHT = 4000;
  const HALF_W = VIRTUAL_W / 2;

  // ======================================== PLATFORM DATA (SHARED) ========================================
  // SMALLER Y  = HIGHER UP
  // PLAYER STARTS AT Y=3900, VICTORY IS Y=100
  const PLATFORM_COUNT = 25;
  const SPACING = LEVEL_HEIGHT / PLATFORM_COUNT;
  const platformData = [];

  for (let i = 1; i < PLATFORM_COUNT; i++) {
    platformData.push({
      xStart: rand(50, HALF_W - 150),
      y: LEVEL_HEIGHT - (i * SPACING),
      width: 180,
      height: 40,
      moveRange: rand(60, 120),
      moveSpeed: rand(40, 100)
    });
  }

  // ======================================== LEFT SIDE (NORMAL CONTROLS) ========================================
  const playerLeft = add([
    sprite("niels", { frame: 11 }),
    pos(HALF_W / 2, LEVEL_HEIGHT - 100),
    area({
      width: 90,
      height: 90,
      offset: vec2(0, 0),
    }),
    body(),
    scale(0.7),
    anchor("center"),
    z(10),
    {
      facingRight: true,
      isMoving: false,
      curState: "idle",
      ridingPlatform: null,
      side: "left"
    },
    "playerLeft"
  ]);

  // ======================================== RIGHT SIDE (INVERTED CONTROLS) - PINK ENTANGLED TWIN ========================================
  const playerRight = add([
    sprite("niels", { frame: 11 }),
    pos(HALF_W + (HALF_W / 2), LEVEL_HEIGHT - 100),
    area({
      width: 90,
      height: 90,
      offset: vec2(0, 0),
    }),
    body(),
    scale(0.7),
    anchor("center"),
    color(rgb(255,61,170)),// PINK!
    z(10), 
    {
      facingRight: true,
      isMoving: false,
      curState: "idle",
      ridingPlatform: null,
      side: "right"
    },
    "playerRight"
  ]);

  // ======================================== GROUND (BOTH SIDES) ========================================
  createSpriteGround(0, LEVEL_HEIGHT - 40, HALF_W, 40);
  createSpriteGround(HALF_W, LEVEL_HEIGHT - 40, HALF_W, 40);

  // ======================================== PLATFORMS (BOTH SIDES, SYNCHRONIZED) ========================================
  platformData.forEach((data, index) => {
    const leftPlat = createSpritePlatform(
      data.xStart,
      data.y,
      data.width,
      data.height,
      data.moveRange,
      data.moveSpeed,
      true
    );

    const rightPlat = createSpritePlatform(
      HALF_W + data.xStart,
      data.y,
      data.width,
      data.height,
      data.moveRange,
      data.moveSpeed,
      false 
    );

    leftPlat.sync = rightPlat;
    rightPlat.sync = leftPlat;
  });

  // ======================================== ONE-WAY PLATFORM SETUP ========================================
  setupOneWayPlatforms(playerLeft);
  setupOneWayPlatforms(playerRight);

  // ======================================== WALLS ========================================
  const WALL_SEGMENT_HEIGHT = 250 * 2;
  const WALL_BUFFER = 2;
  const activeWallSegments = new Map();

  function createWallSegment(index) {
    const yPos = LEVEL_HEIGHT - (index * WALL_SEGMENT_HEIGHT);

   
    const leftWallLeft = add([
      sprite("leftWall"),
      pos(0, yPos),
      scale(vec2(0.7, 2)), 
      area(),
      body({ isStatic: true }),
      z(1), 
      "wallSegment"
    ]);

    const leftWallRight = add([
      sprite("rightWall"),
      pos(HALF_W, yPos),
      scale(vec2(0.7, 2)), 
      area(),
      body({ isStatic: true }),
      anchor("topright"),
      z(1), 
      "wallSegment"
    ]);

   
    const rightWallLeft = add([
      sprite("leftWall"),
      pos(HALF_W, yPos),
      scale(vec2(0.7, 2)),  
      area(),
      body({ isStatic: true }),
      z(1), 
      "wallSegment"
    ]);

    const rightWallRight = add([
      sprite("rightWall"),
      pos(VIRTUAL_W, yPos),
      scale(vec2(0.7, 2)), 
      area(),
      body({ isStatic: true }),
      anchor("topright"),
      z(1),
      "wallSegment"
    ]);

    activeWallSegments.set(index, [leftWallLeft, leftWallRight, rightWallLeft, rightWallRight]);
  }

  function removeWallSegment(index) {
    const segment = activeWallSegments.get(index);
    if (!segment) return;
    segment.forEach(obj => destroy(obj));
    activeWallSegments.delete(index);
  }

  // ======================================== CENTER DIVIDER ========================================
  add([
    rect(2, LEVEL_HEIGHT * 2),
    pos(HALF_W - 1, 0),
    color(0,0,0),
    z(2),
    "divider"
  ]);

  // ======================================== CONTROLS ========================================
  function handlePlayer(player, invertControls) {
    const leftKey = invertControls ? "right" : "left";
    const rightKey = invertControls ? "left" : "right";

    player.onUpdate(() => {
      player.isMoving = false;

      const leftPressed = isKeyDown(leftKey) || virtualKeys[leftKey];
      const rightPressed = isKeyDown(rightKey) || virtualKeys[rightKey];

      if (leftPressed) {
        player.move(-MOVE_SPEED, 0);
        player.facingRight = false;
        player.isMoving = true;
      }

      if (rightPressed) {
        player.move(MOVE_SPEED, 0);
        player.facingRight = true;
        player.isMoving = true;
      }

      if (player.pos.y > LEVEL_HEIGHT + 300) {
        player.pos = vec2(
          player.side === "left" ? HALF_W / 2 : HALF_W + (HALF_W / 2),
          LEVEL_HEIGHT - 200
        );
        player.ridingPlatform = null;
      }

      updatePlayerAnim(player);
    });
  }

  handlePlayer(playerLeft, false);  
  handlePlayer(playerRight, true);  

  // ======================================== JUMP ========================================
  onKeyPress("space", () => {
    if (playerLeft.isGrounded() || playerLeft.ridingPlatform) {
      playerLeft.jump(JUMP_FORCE);
      playerLeft.curState = "jumpStart";
      playerLeft.use(sprite("niels", { frame: 8 }));
      playerLeft.ridingPlatform = null; 
    }
    if (playerRight.isGrounded() || playerRight.ridingPlatform) {
      playerRight.jump(JUMP_FORCE);
      playerRight.curState = "jumpStart";
      playerRight.use(sprite("niels", { frame: 8 }));
      playerRight.use(color(rgb(255,61,170))); // REAPPLY TINT
      playerRight.ridingPlatform = null;
    }
  });

  // ======================================== CAMERA ========================================
  onUpdate(() => {
    const avgY = (playerLeft.pos.y + playerRight.pos.y) / 2;
    const camY = Math.max(avgY + 50, VIRTUAL_H / 2);
    setCamPos(VIRTUAL_W / 2, camY);

    const currentSegment = Math.floor((LEVEL_HEIGHT - camY) / WALL_SEGMENT_HEIGHT);

    for (let i = currentSegment - WALL_BUFFER; i <= currentSegment + WALL_BUFFER; i++) {
      if (i >= 0 && i <= LEVEL_HEIGHT / WALL_SEGMENT_HEIGHT) {
        if (!activeWallSegments.has(i)) {
          createWallSegment(i);
        }
      }
    }

    for (const index of activeWallSegments.keys()) {
      if (Math.abs(index - currentSegment) > WALL_BUFFER + 1) {
        removeWallSegment(index);
      }
    }
  });

  // ======================================== ANIMATION HELPER ========================================
  function updatePlayerAnim(player) {
    const grounded = player.isGrounded() || player.ridingPlatform;
    let newState;

    if (!grounded) {
      if (player.vel.y < - 700) {
        newState = "jumpStart";  
      } else if (player.vel.y > 20) {
        newState = "fall";      
      } else {
        newState = "jumpMid";   
      }
    } else if (player.isMoving) {
      newState = "walk";
    } else {
      newState = "idle";
    }

    if (newState !== player.curState) {
      player.curState = newState;

      if (newState === "walk") {
        player.use(sprite("niels"));
        player.play("walk");
      } else if (newState === "jumpStart") {
        player.use(sprite("niels", { frame: 8 }));
        player.stop();
      } else if (newState === "jumpMid") {
        player.use(sprite("niels", { frame: 9 }));
        player.stop();
      } else if (newState === "fall") {
        player.use(sprite("niels", { frame: 10 }));
        player.stop();
      } else {
        player.use(sprite("niels", { frame: 11 }));
        player.stop();
      }

      if (player.side === "right") {
        player.use(color(rgb(255,61,170)));
      }
    }

    player.flipX = !player.facingRight;
  }

  // ======================================== SUCCESS CHECK ========================================
  const goalY = 100;
  let victoryShown = false;
  
  add([
    rect(HALF_W, 20),
    pos(0, goalY - 10),
    color(rgb(100, 255, 100)),
    opacity(0.3),
    z(1),
    "goal"
  ]);
  
  add([
    rect(HALF_W, 20),
    pos(HALF_W, goalY - 10),
    color(rgb(100, 255, 100)),
    opacity(0.3),
    z(1),
    "goal"
  ]);
  
  add([
    text("GOAL", { size: 24 }),
    pos(HALF_W / 2, goalY),
    anchor("center"),
    color(255, 255, 255),
    z(2)
  ]);
  
  add([
    text("GOAL", { size: 24 }),
    pos(HALF_W + HALF_W / 2, goalY),
    anchor("center"),
    color(255, 255, 255),
    z(2)
  ]);
  
  onUpdate(() => {
    if (!victoryShown && playerLeft.pos.y < goalY && playerRight.pos.y < goalY) {
      victoryShown = true;
      add([
        text("ðŸŽ‰ ENTANGLEMENT COMPLETE! ðŸŽ‰", { size: 32 }),
        pos(VIRTUAL_W / 2, camPos().y - 100),
        anchor("center"),
        color(255, 200, 100),
        z(999), 
        "victory"
      ]);
    }
  });
});

go("vertical-test");

// ======================================== HANDLE RESIZE ========================================
window.addEventListener('resize', () => {
  const newSize = getCanvasSize();
  updateScreenDimensions(newSize.width, newSize.height);

  const canvas = document.getElementById("gameCanvas");
  if (canvas) {
    canvas.style.width = '100vw';
    canvas.style.height = '100vh';
  }
});
</script>

</body>
</html>